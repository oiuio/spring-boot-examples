[toc]

# 并发编程

## 00.基础

## 01.可见性,原子性和有序性:并发编程Bug的源头
### 缓存导致的可见性问题
> 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性
* CPU直接操作的是缓存,在处理数据时,先把数据从内存读取大缓存,在缓存中处理完数据,再把数据写回内存
* 单核CPU中,所有线程在一个CPU上执行,同一个CPU中的缓存,不同的线程是可见的,一个线程修改了值V,另一个线程访问则一定是最新
* 多核CPU中,多个线程可能在不同的CPU上执行,不同的CPU缓存,对线程来说就是不可见的了,如果A-CPU中修改了值V,在B-CPU中的线程则不知道

* 样例:起多个线程同时修改一个变量值,值可能会出现意料之外的结果
  
### 线程切换带来的原子性问题
> 我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性
* 多进程的实现依赖了CPU的时间片轮转,每个进程执行一段时间则会让出CPU给其他进程执行
* 早期的操作系统是基于进程来调度CPU(因为不同进程不共享内存空间,切换需要重新映射内存地址),现代操作系统基于更轻量级的线程来调度
* CPU只能保证CPU指令级别是原子性的,但是一条高级语言通常需要几个CPU指令来完成
* 当线程A从内存取数据V加载到内存时,此时让出CPU由线程B执行,线程B也读取了数据V并修改了数据写回内存,由线程A继续执行,此时数据V还是原数据,写回内存时,覆盖了线程B的操作

* 样例:和上面其实差不多

### 编译优化带来的有序性问题
> 有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序总语句的先后顺序

* 样例:双重锁
> 我们以为new执行是:
> 1.分配一块内存M 
> 2.在内存M上初始化Singleton对象 
> 3.将M的地址赋值给instance变量
> 实际优化后的执行是:
> 1.分配一块内存M 
> 2.将M的地址赋值给instance变量 
> 3.在内存M上初始化Singleton对象
> 线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。

## 02.Java内存模型:看Java如何解决可见性和有序性问题
### 什么是Java内存模型
* 我们已经知道,导致可见性的原因是缓存,导致有序性的问题是编译优化,那么最直接的解决办法就是 **禁用缓存和编译优化** 
* Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法.具体为 **volatile** , **synchronized** 和 **final** 关键字及六项 **Happens-Before规则**

### 使用volatile的困惑
* volatile关键字不是Java特产,C中也有,最原始的含义就是禁用CPU缓存
* 如果我们声明一个volatile变量,它表达的是: 告诉编译器,对这个变量的读写不能使用CPU缓存,必须从内存中读取或者写入

### Happens-Before规则
* 含义:前一个操作的结果对后续操作是可见的
* Happens-Before 约束了编译器的优化行为，虽允许编译器优化,但要求编译器优化后一定遵循该规则
* 与程序员相关的一共有六项,都是与可见性相关

#### 程序的顺序性规则
* 在一个线程中,按照程序顺序执行,前面的操作 Happens-Before 于后续的任意操作

#### volatile变量规则
* 对一个volatile变量的写操作 Happens-before 于后续对这个 volatile 变量的读操作

#### 传递性
* 如果A Happens-Before B, 且B Happens-Before C ,那么A Happens-Before C

#### 管程中锁的规则
* 指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁
* 管程是一种通用的同部原语, 在Java中指的就是synchronized , synchronized是 Java对管程的实现

#### 线程start()规则
* 主线程A启动子线程B后 , 子线程B能看到主线程在启动子线程B前的操作
* 换句话: 线程A调用线程B的start()方法 , 那么该start()操作 Happens-Before 于线程B中的任意操作

#### 线程join()规则
* 主线程A等待子线程B完成(主线程A通过调用子线程B的join()方法实现),当子线程B完成后,主线程能够看到子线程的操作(对共享变量的操作)
* 换句话: 线程A中,调用线程B的join()并成功返回,那么B线程中的任意操作 Happens-Before 于该join()操作的返回 

### 被我们忽视的final
* 1.5版本前 final 的优化类似于双重锁的单利 , 构造函数的错误重排导致线程可能看到 final 的变量
* 1.5版本后 Java 内存模型对final类型变量重排序进行了约束. 现在只要我们构造函数没有逸出就不会出问题了

### 思考
> 有一个共享变量abc , 在一个线程里设置了abc = 3 , 有哪些方法可以使其他线程能够看到abc ==3

* thread join , volitail , synchronized , AtomicInteger

## 03.互斥锁(上): 解决原子性问题
* 原子性问题的源头是线程切换
* 同一时刻只有一个线程执行 称为 **互斥**
* 锁需要与锁保护的资源对应起来

### synchronized 关键字
* Java语言提供的 synchronized 关键字,是锁的一种实现,编译器会在 synchronized 修饰的方法或代码块前后自当加上 lock() 和 unlock()
* unlock()操作会使其他缓存的变量失效,需要重新从内存中加载变量值
* 当 synchronized 修饰非静态方法时 , 锁定的是当前实例对象 this
* 当 synchronized 修饰静态方法时 , 锁定的是当前类的 Class 对象
* 通常 , 受保护资源和锁之间的关联关系是N:1的关系 . 一个锁可以保护多个资源

## 04.互斥锁(下): 如何用一把锁保护多个资源
* 对于没有关联关系的资源 , 不同的资源用不同的锁保护. 用不同的锁对受保护资源进行精细化管理,能够提升性能,叫 **细粒度锁**
* 对于有关联关系的资源 , this锁只能保护自己的资源 , 不同的资源可以共享同一把锁 , 可以传入一把锁 或者使用 .class
* "原子性"的本质 是中间状态对外不可见 , 解决原子性问题 , 是要保证中间状态对外不可见.

### 思考
* 是否可以使用 this.balance 或者 this.passwword作为锁呢
* 答:不能使用可变对象作为锁

## 05.一不小心就死锁了,怎么办?
* 死锁: 一组互相竞争资源的线程因互相等待 , 导致"永久"阻塞的现象

### 预防死锁
> 死锁的四大条件 : 互斥 , 占用且等待(请求与保持) , 补可抢占(剥夺) , 循环等待
* 互斥: 我们用锁就是为了互斥所以没办法破坏
* 占用且等待: 一次性申请所有资源 , 就不用等待了
* 不可抢占: 占用部分资源的线程进一步申请其他资源时, 如果申请不到可以主动释放它占有的资源
* 循环等待: 可以按照资源的线性排序,申请时先申请序号小的,在申请序号大的,这样线性化后就不存在循环了

### 破坏占用且等待条件
* 为了做到同时申请,可以设置一个单例来进行管理,由一个人统一管理. 在进行操作时由这个单例统一锁定和解锁
  
### 破坏不可抢占条件
* 目前 synchronized 做不到 , 在synchronized申请资源时如果申请不到 , 线程直接进入阻塞状态

### 破坏循环等待条件
* 破坏这个条件,需要先队资源进行排序,然后按需申请资源,避免出现T1等待T2,T2等待T1

## 06.用"等待-通知"机制优化循环等待
* 等待-通知机制可以有多种实现方式, Java语言内置的 synchronized 配合 wait(),notify(),notifyAll()这三个方法可以轻松实现

> 当一个线程进入 synchronized 保护的临界区,其他线程只能进入(左边)等待队列里等待. **这个等待队列和互斥锁市一对一的关系,每个互斥锁都有自己独立的等待队列**
> 当调用wait()方法后, 当前线程会被阻塞,并且进入(右边)等待队列,这个等待队列也是 **互斥锁的等待队列** . 线程在进入等待队列的同时, **会释放持有的互斥锁** ,线程释放锁后,其他线程就有机会持有锁并进入临界区
> 当线程要求的条件满足时,通过java对象的notify()和notifyAll()方法,通知等待队列 **(互斥锁的等待队列)** 中的线程,告诉它条件 **曾经满足过**

* notify()只能保证在通知时间点,条件是满足的 , 执行时间点是否满足还得重新判断
* wait(),notify(),notifyAll()操作的都是互斥锁的等待对俄,如果 synchronized 锁的是this,那么就是this.wait(),notify()... 如果锁的是target那么就是 target.wait()...
* wait(),notify(),notifyAll()能被调用的前提是已经获取了相应的互斥锁,它们都是在 synchronized{}内部被调用的, 如果在外部调用会抛出IllegalMonitorStateException

### 尽量使用 notifyAll
* notify()会随机通知等待队列中的一个线程,而notifyAll会通知等待线程中的所有线程, 有可能使线程永远没机会被唤醒

### 思考: wait()和sleep()的区别
* wait会释放锁 sleep不会释放
* wait只能在同步方法和同步块中调用 sleep可在任何地方
* wait是Object的方法 sleep是Thread的方法
* wait无需捕获异常 , sleep需要
* sleep需要指定等待时间

## 07.安全性,活跃性以及性能问题
### 安全性
* 线程安全bug的源头: 原子性 , 可见性 , 有序性
* 存在会发生变化的共享数据,才会有线程安全的问题. 这种问题叫 **竞太条件** : 程序的执行结果依赖程序执行的顺序

### 活跃性
> 活跃性问题就是某个操作无法执行下去,除了死锁,还有 "活锁","饥饿"
* 活锁: 对应现实时间就是互相谦让对方先行 , 解决方案可以设置一个随机等待时间
* 饥饿: 线程因为无法访问所需资源而无法执行下去的情况.
> 在cpu繁忙时,优先级低的线程得到执行的机会小. 持有锁的线程如果执行时间过长,都会导致饥饿问题
* 饥饿解决方案: 1.保证资源充足 2.公平地分配资源 3.避免持有锁的线程长时间执行 .其中1.3场景有限,第二种用公平锁解决

### 性能问题
* 锁使用过度可能使串行化的范围过大,导致不能发挥多线程优势
* 阿姆达尔定律(Amdahl)代表处理器并行运算之后效率提升的能理 S = 1 / [(1-p)+p/n] n为cpu核数,p为并行百分比 1-p为串行百分比 如果n无穷大 串行比为5% ,加速比S的极限就是20 ,只能提升20倍性能
* JDK并发包有一堆东西,有很大一部分原因是为了提升在某个特定领域的性能

* 1. 使用锁会带来性能问题,最好的方案是使用无锁的算法和数据结构
> 相关技术: 本地存储(Thread Local Storage TLS),写入时复制(Copy-on-write),乐观锁等; Java并发包里的原子类也是一种无锁的数据结构,Disruptor是一个无锁的内存队列

* 2. 减少锁的持有时间.互斥锁的本质是将并行的程序串行化,增加并行度就一定要减少持有锁的时间.
> 例如细粒度锁,典型例子ConcurrentHashMap,使用了分段锁,还有读写锁,读是无锁的写才互斥

* 吞吐量:单位时间内能处理的请求数量. 越高性能越好
* 延迟:从发出请求到收到响应的时间. 越小性能越好.
* 并发量:能同时处理请求的数量. 一般来说并发量提高延迟也会增加,所以延迟一般基于并发量来说 例如并发量1000 延迟50ms

## 08.管程:并发编程的万能钥匙
* 管程:管理共享变量以及对共享变量的操作,让他们支持并发
* 管程和信号量是等价的,等价是指,管程能够实现信号量,信号量也能实现管程
* 管程的三种模型: Hasen模型,Hoare模型,MESA模型
![管程模型代码化的语义](https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png)

### MESA模型
* 并发领域两大核心问题:
  * 互斥: 同一时刻只允许一个线程访问共享资源
  * 同步: 线程之间如何通信,协作

* 管程如何解决互斥问题: 
* 管程如何解决同步问题: 

## 09.Java线程(上):Java线程的生命周期

### 通用线程的生命周期: 
* **初始状态**,**可运行状态**,**运行状态**,**运行状态**,**休眠状态**和**终止状态**
![通用线程状态转换图-五态模型](https://static001.geekbang.org/resource/image/9b/e5/9bbc6fa7fb4d631484aa953626cf6ae5.png)

详细解释:
1. **初始状态**: 线程已被创建,但还不允许分配CPU执行. 这个状态是编程语言特有,代表它在编程语言层面被创建,在操作系统里还未创建
2. **可运行状态**: 线程可以分配CPU执行. 这个状态下,在操作系统中线程已被创建了
3. **运行状态**: 操作系统将CPU分配可一个处于可运行状态的线程,该线程就转换成了运行状态.
4. **休眠状态**: 运行状态的线程如果调用一个阻塞API(ex:以阻塞方式读文件)或者等待某个事件(ex:条件变量),线程就会转换到休眠状态,同时释放CPU使用权. 休眠状态的线程**永远没有机会获得CPU使用权**,当等待的事件出现了,它可以转变成**可运行状态**
5. **终止状态**: 线程执行完或者出现异常时,就会进入终止状态

### Java中线程的生命周期:
* NEW(初始化状态),RUNNABLE(可运行/运行状态),BLOCKED(阻塞状态),WAITING(无时限等待),TIMED_WAITING(有时限等待),TERMINATED(终止状态)
* 在操作系统层面,BLOCKED,WAITING,TIMED_WAITING 就是休眠状态,JAVA线程处于三种状态之一,就永远没有CPU使用权
![通用线程状态转换图-Java 中的线程状态转换图](https://static001.geekbang.org/resource/image/3f/8c/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png)

1. RUNNABLE 与 BLOCKED 的状态转换
只有在等待synchronized的隐式锁时,被阻塞的线程会转换恶的BLOCKED状态.
JVM不关心操作系统调度状态,它认为等待CPU与I/O没有区别,所以调用阻塞API并不会使线程发生状态改变.

2. RUNNABLE 于 WAITING 的状态转换
