[toc]

# 并发编程

## 00.基础

## 01.可见性,原子性和有序性:并发编程Bug的源头
### 缓存导致的可见性问题
> 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性
* CPU直接操作的是缓存,在处理数据时,先把数据从内存读取大缓存,在缓存中处理完数据,再把数据写回内存
* 单核CPU中,所有线程在一个CPU上执行,同一个CPU中的缓存,不同的线程是可见的,一个线程修改了值V,另一个线程访问则一定是最新
* 多核CPU中,多个线程可能在不同的CPU上执行,不同的CPU缓存,对线程来说就是不可见的了,如果A-CPU中修改了值V,在B-CPU中的线程则不知道

* 样例:起多个线程同时修改一个变量值,值可能会出现意料之外的结果
  
### 线程切换带来的原子性问题
> 我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性
* 多进程的实现依赖了CPU的时间片轮转,每个进程执行一段时间则会让出CPU给其他进程执行
* 早期的操作系统是基于进程来调度CPU(因为不同进程不共享内存空间,切换需要重新映射内存地址),现代操作系统基于更轻量级的线程来调度
* CPU只能保证CPU指令级别是原子性的,但是一条高级语言通常需要几个CPU指令来完成
* 当线程A从内存取数据V加载到内存时,此时让出CPU由线程B执行,线程B也读取了数据V并修改了数据写回内存,由线程A继续执行,此时数据V还是原数据,写回内存时,覆盖了线程B的操作

* 样例:和上面其实差不多

### 编译优化带来的有序性问题
> 有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序总语句的先后顺序

* 样例:双重锁
> 我们以为new执行是:
> 1.分配一块内存M 
> 2.在内存M上初始化Singleton对象 
> 3.将M的地址赋值给instance变量
> 实际优化后的执行是:
> 1.分配一块内存M 
> 2.将M的地址赋值给instance变量 
> 3.在内存M上初始化Singleton对象
> 线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。

## 02.Java内存模型:看Java如何解决可见性和有序性问题
### 什么是Java内存模型
* 我们已经知道,导致可见性的原因是缓存,导致有序性的问题是编译优化,那么最直接的解决办法就是 **禁用缓存和编译优化** 
* Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法.具体为 **volatile** , **synchronized** 和 **final** 关键字及六项 **Happens-Before规则**

### 使用volatile的困惑
* volatile关键字不是Java特产,C中也有,最原始的含义就是禁用CPU缓存
* 如果我们声明一个volatile变量,它表达的是: 告诉编译器,对这个变量的读写不能使用CPU缓存,必须从内存中读取或者写入

### Happens-Before规则
* 含义:前一个操作的结果对后续操作是可见的
* Happens-Before 约束了编译器的优化行为，虽允许编译器优化,但要求编译器优化后一定遵循该规则
* 与程序员相关的一共有六项,都是与可见性相关

#### 程序的顺序性规则
* 在一个线程中,按照程序顺序执行,前面的操作 Happens-Before 于后续的任意操作

#### volatile变量规则
* 对一个volatile变量的写操作 Happens-before 于后续对这个 volatile 变量的读操作

#### 传递性
* 如果A Happens-Before B, 且B Happens-Before C ,那么A Happens-Before C

#### 管程中锁的规则
* 指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁
* 管程是一种通用的同部原语, 在Java中指的就是synchronized , synchronized是 Java对管程的实现

#### 线程start()规则
* 主线程A启动子线程B后 , 子线程B能看到主线程在启动子线程B前的操作
* 换句话: 线程A调用线程B的start()方法 , 那么该start()操作 Happens-Before 于线程B中的任意操作

#### 线程join()规则
* 主线程A等待子线程B完成(主线程A通过调用子线程B的join()方法实现),当子线程B完成后,主线程能够看到子线程的操作(对共享变量的操作)
* 换句话: 线程A张,调用线程B的join()并成功返回,那么B线程中的任意操作 Happens-Before 于该join()操作的返回 

### 被我们忽视的final
* 1.5版本前 final 的优化类似于双重锁的单利 , 构造函数的错误重排导致线程可能看到 final 的变量
* 1.5版本后 Java 内存模型对final类型变量重排序进行了约束. 现在只要我们构造函数没有逸出就不会出问题了

### 思考
> 有一个共享变量abc , 在一个线程里设置了abc = 3 , 有哪些方法可以使其他线程能够看到abc ==3

* thread join , volitail , synchronized , AtomicInteger

## 03.互斥锁(上): 解决原子性问题
* 原子性问题的源头是线程切换
* 同一时刻只有一个线程执行 称为 **互斥**
* 锁需要与锁保护的资源对应起来

### synchronized 关键字
* Java语言提供的 synchronized 关键字,是锁的一种实现,编译器会在 synchronized 修饰的方法或代码块前后自当加上 lock() 和 unlock()
* unlock()操作会使其他缓存的变量失效,需要重新从内存中加载变量值
* 当 synchronized 修饰非静态方法时 , 锁定的是当前实例对象 this
* 当 synchronized 修饰静态方法时 , 锁定的是当前类的 Class 对象
* 通常 , 受保护资源和锁之间的关联关系是N:1的关系 . 一个锁可以保护多个资源

## 04.互斥锁(下): 如何用一把锁保护多个资源
