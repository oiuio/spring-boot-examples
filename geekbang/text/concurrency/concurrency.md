
# 并发编程
## 01.可见性,原子性,有序性,
### 缓存导致的可见性问题
> 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性
* CPU直接操作的是缓存,在处理数据时,先把数据从内存读取大缓存,在缓存中处理完数据,再把数据写回内存
* 单核CPU中,所有线程在一个CPU上执行,同一个CPU中的缓存,不同的线程是可见的,一个线程修改了值V,另一个线程访问则一定是最新
* 多核CPU中,多个线程可能在不同的CPU上执行,不同的CPU缓存,对线程来说就是不可见的了,如果A-CPU中修改了值V,在B-CPU中的线程则不知道

* 样例:起多个线程同时修改一个变量值,值可能会出现意料之外的结果
  
### 线程切换带来的原子性问题
> 我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性
* 多进程的实现依赖了CPU的时间片轮转,每个进程执行一段时间则会让出CPU给其他进程执行
* 早期的操作系统是基于进程来调度CPU(因为不同进程不共享内存空间,切换需要重新映射内存地址),现代操作系统基于更轻量级的线程来调度
* CPU只能保证CPU指令级别是原子性的,但是一条高级语言通常需要几个CPU指令来完成
* 当线程A从内存取数据V加载到内存时,此时让出CPU由线程B执行,线程B也读取了数据V并修改了数据写回内存,由线程A继续执行,此时数据V还是原数据,写回内存时,覆盖了线程B的操作

* 样例:和上面其实差不多

### 编译优化带来的有序性问题
> 有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序总语句的先后顺序

* 样例:双重锁
> 我们以为new执行是:1.分配一块内存M 2.在内存M上初始化Singleton对象 3.将M的地址赋值给instance变量
> 实际优化后的执行是:1. 分配一块内存M 2.将M的地址赋值给instance变量 3.在内存M上初始化Singleton对象
> 线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。
